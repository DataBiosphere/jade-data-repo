package bio.terra.service.dataset;

import bio.terra.model.AssetModel;
import bio.terra.model.AssetTableModel;
import bio.terra.model.ColumnModel;
import bio.terra.model.IntPartitionOptionsModel;
import bio.terra.model.PartitionStrategy;
import bio.terra.model.RelationshipModel;
import bio.terra.model.RelationshipTermModel;
import bio.terra.model.DatasetRequestModel;
import bio.terra.model.DatasetSpecificationModel;
import bio.terra.model.TableModel;
import bio.terra.common.ValidationUtils;
import org.springframework.stereotype.Component;
import org.springframework.validation.Errors;
import org.springframework.validation.Validator;

import javax.validation.constraints.NotNull;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Optional;

import static java.util.stream.Collectors.toList;

/**
 * This validator runs along with the constraint validation that comes from the Models generated by swagger-codegen.
 * The constraints will be able to handle things like nulls, but not things like uniqueness or other structural
 * validations.
 *
 * There are a lot of null checks here because this will still be called even if a constraint validation failed.
 * Spring will not shortcut out early if a validation fails, so this Validator will still get nulls and should only
 * validate if the field is present.
 */
@Component
public class DatasetRequestValidator implements Validator {

    @Override
    public boolean supports(Class<?> clazz) {
        return true;
    }

    private static class SchemaValidationContext {

        private HashMap<String, HashSet<String>> tableColumnMap;
        private HashSet<String> relationshipNameSet;

        SchemaValidationContext() {
            tableColumnMap = new HashMap<>();
            relationshipNameSet = new HashSet<>();
        }

        void addTable(String tableName, List<String> columnNames) {
            tableColumnMap.put(tableName, new HashSet<>(columnNames));
        }

        void addRelationship(String relationshipName) {
            relationshipNameSet.add(relationshipName);
        }

        boolean isValidTable(String tableName) {
            return tableColumnMap.containsKey(tableName);
        }

        boolean isValidTableColumn(String tableName, String columnName) {
            return isValidTable(tableName) && tableColumnMap.get(tableName).contains(columnName);
        }

        boolean isValidRelationship(String relationshipName) {
            return relationshipNameSet.contains(relationshipName);
        }
    }

    private void validateDatasetName(String datasetName, Errors errors) {
        // NOTE: We used to manually check the name against a pattern here, but the latest
        // versions of Swagger codegen now auto-generate an equivalent check.
        if (datasetName == null) {
            errors.rejectValue("name", "DatasetNameMissing");
        }
    }

    private void validateTable(TableModel table, Errors errors, SchemaValidationContext context) {
        String tableName = table.getName();
        List<ColumnModel> columns = table.getColumns();
        List<String> primaryKeyList = table.getPrimaryKey();

        if (tableName != null && columns != null) {
            List<String> columnNames = columns.stream().map(ColumnModel::getName).collect(toList());
            if (ValidationUtils.hasDuplicates(columnNames)) {
                errors.rejectValue("schema", "DuplicateColumnNames");
            }
            if (primaryKeyList != null) {
                if (!columnNames.containsAll(primaryKeyList)) {
                    errors.rejectValue("schema", "MissingPrimaryKeyColumn");
                }

                for (ColumnModel column : columns) {
                    if (primaryKeyList.contains(column.getName()) && column.isArrayOf()) {
                        errors.rejectValue("schema", "PrimaryKeyArrayColumn");
                    }
                }
            }

            context.addTable(tableName, columnNames);
        }

        Optional<PartitionStrategy> strategy = Optional.ofNullable(table.getPartitionStrategy());
        Optional<String> partitionColumnName = Optional.ofNullable(table.getPartitionColumn());
        Optional<ColumnModel> partitionColumn = partitionColumnName.flatMap(colName ->
            columns.stream().filter(col -> colName.equals(col.getName())).findFirst());
        Optional<IntPartitionOptionsModel> intOptions = Optional.ofNullable(table.getIntPartitionOptions());

        if (strategy.isPresent()) {
            PartitionStrategy strat = strategy.get();
            if (strat == PartitionStrategy.INGEST_TIME) {
                if (partitionColumnName.isPresent()) {
                    errors.rejectValue("schema", "PartitionColumn",
                        "Cannot specify a partitionColumn with the 'ingest_time' partitionStrategy");
                }
                if (intOptions.isPresent()) {
                    errors.rejectValue("schema", "IntPartitionOptions",
                        "intPartitionOptions are only valid with the 'int_column' partitionStrategy");
                }
            } else if (strat == PartitionStrategy.DATE_OR_TIMESTAMP_COLUMN) {
                if (partitionColumnName.isPresent()) {
                    if (partitionColumn.isPresent()) {
                        String type = partitionColumn.get().getDatatype();
                        if (!"DATE".equalsIgnoreCase(type) && !"TIMESTAMP".equalsIgnoreCase(type)) {
                            errors.rejectValue("schema", "InvalidPartitionColumnType",
                                "partitionColumn must refer to a DATE or TIMESTAMP column when " +
                                    "using the 'date_or_timestamp_column' partitionStrategy");
                        }
                    } else {
                        errors.rejectValue("schema", "InvalidPartitionColumnName",
                            partitionColumnName.get() + " is not a valid column");
                    }
                } else {
                    errors.rejectValue("schema", "MissingPartitionColumn",
                        "partitionColumn must be specified when using the 'date_or_time_column' partitionStrategy");
                }
                if (intOptions.isPresent()) {
                    errors.rejectValue("schema", "IntPartitionOptions",
                        "intPartitionOptions are only valid with the 'int_column' partitionStrategy");
                }
            } else {
                if (partitionColumnName.isPresent()) {
                    if (partitionColumn.isPresent()) {
                        String type = partitionColumn.get().getDatatype();
                        if (!"INTEGER".equalsIgnoreCase(type) && !"INT64".equalsIgnoreCase(type)) {
                            errors.rejectValue("schema", "InvalidPartitionColumnType",
                                "partitionColumn must refer to an INTEGER or INT64 column when " +
                                    "using the 'int_column' partitionStrategy");
                        }
                    } else {
                        errors.rejectValue("schema", "InvalidPartitionColumnName",
                            partitionColumnName.get() + " is not a valid column");
                    }
                } else {
                    errors.rejectValue("schema", "MissingPartitionColumn",
                        "partitionColumn must be specified when using the 'int_column' partitionStrategy");
                }
                if (intOptions.isPresent()) {
                    long min = intOptions.get().getMin();
                    long max = intOptions.get().getMax();
                    long interval = intOptions.get().getInterval();

                    if (max <= min) {
                        errors.rejectValue("schema", "InvalidIntPartitionRange",
                            "Max partition value must be larger than min partition value");
                    }
                    if (interval <= 0) {
                        errors.rejectValue("schema", "InvalidIntPartitionInterval",
                            "Partition interval must be >= 1");
                    }
                } else {
                    errors.rejectValue("schema", "MissingIntPartitionOptions",
                        "intPartitionOptions must be specified when using the 'int_column' partitionStrategy");
                }
            }
        } else {
            if (partitionColumnName.isPresent()) {
                errors.rejectValue("schema", "PartitionColumn",
                    "partitionColumn not allowed when partitionStrategy is null");
            }
            if (intOptions.isPresent()) {
                errors.rejectValue("schema", "IntPartitionOptions",
                    "intPartitionOptions not allowed when partitionStrategy is null");
            }
        }
    }

    private void validateRelationshipTerm(RelationshipTermModel term, Errors errors, SchemaValidationContext context) {
        String table = term.getTable();
        String column = term.getColumn();
        if (table != null && column != null) {
            if (!context.isValidTableColumn(table, column)) {
                errors.rejectValue("schema", "InvalidRelationshipTermTableColumn",
                    "invalid table '" + table + "." + column + "'");
            }
        }
    }

    private void validateRelationship(RelationshipModel relationship, Errors errors, SchemaValidationContext context) {
        RelationshipTermModel fromTerm = relationship.getFrom();
        if (fromTerm != null) {
            validateRelationshipTerm(fromTerm, errors, context);
        }

        RelationshipTermModel toTerm = relationship.getTo();
        if (toTerm != null) {
            validateRelationshipTerm(toTerm, errors, context);
        }

        String relationshipName = relationship.getName();
        if (relationshipName != null) {
            context.addRelationship(relationshipName);
        }
    }

    private void validateAssetTable(
        AssetTableModel assetTable,
        Errors errors,
        SchemaValidationContext context) {

        String tableName = assetTable.getName();
        List<String> columnNames = assetTable.getColumns();
        if (tableName != null && columnNames != null) {
            // An empty list acts like a wildcard to include all columns from a table in the asset specification.
            if (columnNames.size() == 0) {
                if (!context.isValidTable(tableName)) {
                    errors.rejectValue("schema", "InvalidAssetTable",
                        "Invalid asset table: " + tableName);
                }
            } else {
                columnNames.forEach(
                    (columnName) -> {
                        if (!context.isValidTableColumn(tableName, columnName)) {
                            errors.rejectValue("schema", "InvalidAssetTableColumn",
                                "Invalid asset table: " + tableName + " column: " + columnName);
                        }
                    }
                );
            }
        }
    }

    private void validateAsset(AssetModel asset, Errors errors, SchemaValidationContext context) {
        List<AssetTableModel> assetTables = asset.getTables();

        if (assetTables != null) {
            boolean hasRootTable = false;
            for (AssetTableModel assetTable : assetTables) {
                validateAssetTable(assetTable, errors, context);
                if (assetTable.getName().equals(asset.getRootTable())) {
                    if (!context.isValidTableColumn(asset.getRootTable(), asset.getRootColumn())) {
                        errors.rejectValue("schema", "InvalidRootColumn",
                            "Invalid root table column. Table: " + asset.getRootTable() +
                                " Column: " + asset.getRootColumn());
                    }
                    hasRootTable = true;
                }
            }
            if (!hasRootTable) {
                errors.rejectValue("schema", "NoRootTable");
            }
        }

        List<String> follows = asset.getFollow();
        if (follows != null) {
            if (follows.stream().anyMatch(relationshipName -> !context.isValidRelationship(relationshipName))) {
                errors.rejectValue("schema", "InvalidFollowsRelationship");
            }
        }
        // TODO: There is another validation that can be done here to make sure that the graph is connected that has
        // been left out to avoid complexity before we know if we're going keep using this or not.
    }

    private void validateSchema(DatasetSpecificationModel schema, Errors errors) {
        SchemaValidationContext context = new SchemaValidationContext();
        List<TableModel> tables = schema.getTables();
        if (tables != null) {
            List<String> tableNames = tables.stream().map(TableModel::getName).collect(toList());
            if (ValidationUtils.hasDuplicates(tableNames)) {
                errors.rejectValue("schema", "DuplicateTableNames");
            }
            tables.forEach((table) -> validateTable(table, errors, context));
        }

        List<RelationshipModel> relationships = schema.getRelationships();
        if (relationships != null) {
            List<String> relationshipNames = relationships.stream().map(RelationshipModel::getName).collect(toList());
            if (ValidationUtils.hasDuplicates(relationshipNames)) {
                errors.rejectValue("schema", "DuplicateRelationshipNames");
            }
            relationships.forEach((relationship) -> validateRelationship(relationship, errors, context));
        }

        List<AssetModel> assets = schema.getAssets();
        if (assets != null) {
            List<String> assetNames = assets.stream().map(AssetModel::getName).collect(toList());
            if (ValidationUtils.hasDuplicates(assetNames)) {
                errors.rejectValue("schema", "DuplicateAssetNames");
            }
            assets.forEach((asset) -> validateAsset(asset, errors, context));
        }
    }

    @Override
    public void validate(@NotNull Object target, Errors errors) {
        if (target != null && target instanceof DatasetRequestModel) {
            DatasetRequestModel datasetRequest = (DatasetRequestModel) target;
            validateDatasetName(datasetRequest.getName(), errors);
            DatasetSpecificationModel schema = datasetRequest.getSchema();
            if (schema != null) {
                validateSchema(schema, errors);
            }
        }
    }
}
